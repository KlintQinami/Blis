int char_to_digit(u8 digit) {
  if (digit == '0') {
    return 0;
  } else if (digit == '1') {
    return 1;
  } else if (digit == '2') {
    return 2;
  } else if (digit == '3') {
    return 3;
  } else if (digit == '4') {
    return 4;
  } else if (digit == '5') {
    return 5;
  } else if (digit == '6') {
    return 6;
  } else if (digit == '7') {
    return 7;
  } else if (digit == '8') {
    return 8;
  } else if (digit == '9') {
    return 9;
  }

  return -1;
}

float char_to_digitf(u8 digit) {
  if (digit == '0') {
    return 0.;
  } else if (digit == '1') {
    return 1.;
  } else if (digit == '2') {
    return 2.;
  } else if (digit == '3') {
    return 3.;
  } else if (digit == '4') {
    return 4.;
  } else if (digit == '5') {
    return 5.;
  } else if (digit == '6') {
    return 6.;
  } else if (digit == '7') {
    return 7.;
  } else if (digit == '8') {
    return 8.;
  } else if (digit == '9') {
    return 9.;
  }

  return -1.;
}

// Converts a substring into an integer.
//
// Inputs:
//   string: u8[] containing the substring to be parsed
//   start: the index of the first character of the substring
//   end: the index of the last character of the substring
// Outputs:
//   result: the integer represented by the substring
//   returns: 0 if successful, 1 otherwise
int substring_to_integer(u8[] string, int start, int end, out int result) {
  //reject nonsensical input
  int str_length = length(string);
  if (str_length == 0 || end >= str_length || start < 0 || start > end) {
    return 1;
  }
  result = 0;
  int i;
  for (i = start; i <= end; i = i + 1) {
    int digit = char_to_digit(string[i]);
    if (digit < 0) {
      return 1;
    }
    //compute the place value of this digit
    int place_value = 1;
    int j;
    for (j = 0; j < end - i; j = j + 1) {
      place_value = place_value * 10;
    }
    result = result + digit * place_value;
  }
  return 0;
}

// Converts a substring into a float.
// The substring must contain a decimal point and can have a leading '-' symbol.
// It may not contain e or E.
// 
// Inputs:
//   string: u8[] containing the substring to be parsed
//   start: the index of the first character of the substring
//   end: the index of the last character of the substring
// Output:
//   result: the float represented by the substring
//   returns: 0 if successful, 1 otherwise
int substring_to_float(u8[] string, int start, int end, out float result) {
  //reject nonsensical input
  int str_length = length(string);
  if (str_length == 0 || end >= str_length || start < 0 || start >= end) {
    return 1;
  }
  //check for a leading '-' symbol
  float sign = 1.0;
  if (string[start] == '-') {
    sign = -1.0;
    start = start + 1;
    if (start == end) {
      return 1;
    }
  }
  //determine the position of the decimal point
  int point = -1;
  int i;
  for (i = start; i <= end; i = i + 1) {
    if (string[i] == '.') {
      if (point == -1) {
        point = i;
      } else {
        //error: contains multiple decimal points
        return 1;
      }
    }
  }
  if (point == -1) {
    //error: no decimal point found
    return 1;
  }
  result = 0.;
  //compute the integer part
  if (point > start) {
    int i;
    for (i = start; i < point; i = i + 1) {
      float digit = char_to_digitf(string[i]);
      if (digit < 0.) {
        return 1;
      }
      float place_value = 1.;
      int j;
      for (j = 0; j < point - 1 - i; j = j + 1) {
        place_value = place_value * 10.;
      }
      result = result + digit * place_value;
    }
  }
  //compute the decimal part
  if (point < end) {
    int i;
    for (i = point + 1; i <= end; i = i + 1) {
      float digit = char_to_digitf(string[i]);
      if (digit < 0.) {
        return 1;
      }
      float place_value = 0.1;
      int j;
      for ( j = 0; j < i - (point + 1); j = j + 1) {
        place_value = place_value / 10.0;
      }
      result = result + digit * place_value;
    }
  }
  result = sign * result;
  return 0;
}
// Parses an obj file such that: 
//   Lines starting with #  and blank lines are ignored.
//   Lines starting with v describe vertices. E.g. v -1.1 43. -.123
//   Lines starting with f describe faces. E.g. f 0 1 2
// Inputs:
//   fpath: path to the obj file
//   numVertices: the number of vertices in the obj file
//   numFaces: the number of faces in the obj file
// Outputs:
//   verts: vec3[] of vertices
//   tris: ivec3[] of faces
//   returns: 0 if successful, 1 otherwise
int read_obj(u8[] fpath, int numVertices, int numFaces, out vec3[] verts, out ivec3[] tris) {
  verts = vec3[](numVertices);
  tris = ivec3[](numFaces);
  int vcount = 0;
  int fcount = 0;
  //read file
  u8[] file = read_file(fpath);
  int file_length = length(file);
  int cursor = 0;
  //prepare line buffer
  int maximumLineLength = 128;
  u8[] line_buffer = u8[](maximumLineLength);
  int line_buffer_count = 0;
  int space1 = 0;
  int space2 = 0;
  //iterate through the file
  u8 ch;
  while (cursor < file_length) {
    ch = file[cursor];
    if ( ch == '\n' ) {
      if (line_buffer[0] == '#' || line_buffer_count == 0) {
        //ignore comments or blank lines
      } else if (line_buffer[0] == 'v' && line_buffer[1] == ' ') {
        //got a vertex
        vec3 v;
        if (substring_to_float(line_buffer,2,space1-1, v.x) != 0) {return 1;}
        if (substring_to_float(line_buffer,space1+1,space2-1, v.y) != 0) {return 1;}
        if (substring_to_float(line_buffer,space2+1,line_buffer_count-1,v.z) != 0) {return 1;}
        verts[vcount] = v;
        vcount = vcount + 1;
      } else if (line_buffer[0] == 'f' && line_buffer[1] == ' ') {
        //got a face
        ivec3 f;
        if (substring_to_integer(line_buffer,2,space1-1, f.x) != 0) {return 1;}
        if (substring_to_integer(line_buffer,space1+1,space2-1, f.y) != 0) {return 1;}
        if (substring_to_integer(line_buffer,space2+1,line_buffer_count-1,f.z) != 0) {return 1;}
        tris[fcount] = f;
        fcount = fcount + 1;
      } else {
        return 1;
      }
      //reset line_buffer
      line_buffer = u8[](maximumLineLength);
      line_buffer_count = 0;
      space1 = 0;
      space2 = 0;
      cursor = cursor + 1;
      continue;
    } else if ( ch == ' ' && line_buffer_count > 1) {
      if (space1 == 0) {
        space1 = line_buffer_count;
      } else if (space2 == 0) {
        space2 = line_buffer_count;
      }
    }
    line_buffer[line_buffer_count] = ch;
    line_buffer_count = line_buffer_count + 1;
    cursor = cursor + 1;
  }
  return 0;
}

int main()
{
  u8[12] path = "./kitten.obj";
  int numVertices = 14472;
  int numFaces = 28944;
  u8[] fpath = u8[](length(path));
  int i;
  for (i = 0; i < length(path); i = i + 1) {
    fpath[i] = path[i];
  }
  vec3[] verts;
  ivec3[] tris;
  if (read_obj(fpath,numVertices,numFaces,verts,tris) != 0) {
    return 1;
  }

  //print out some of the results to show it worked!
  vec3 temp1 = verts[numVertices - 1];
  printf(temp1.x);
  printf(temp1.y);
  printf(temp1.z);
  ivec3 temp2 = tris[numFaces - 1];
  printi(temp2.x);
  printi(temp2.y);
  printi(temp2.z);
  return 0;
}
